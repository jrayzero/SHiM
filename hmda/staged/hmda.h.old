#pragma once

#include <array>

#include "builder/dyn_var.h"
#include "builder/static_var.h"
#include "builder/builder.h"
#include "builder/builder_context.h"

#include "common/functors.h"

#include "common/format.h"
#include "traits.h"
#include "format.h"
#include "utils.h"
#include "fwd.h"
#include "exprs.h"

/*
 * The Hierarchical Data Types
 */

namespace hmda {

namespace staged {

using loop_type = int32_t;

// A staged representation of a hierarchical Block
template<typename Elem, int Rank, typename BExtents>
struct Block {
  
  using self = Block<Elem, Rank, BExtents>;
  static const int rank = Rank;

  Block(const BExtents &bextents, const builder::dyn_var<Elem *> &data)
    : bextents(bextents), primary_extents(std::move(bextents)), data(data) {
    static_assert(is_tuple<BExtents>(), "Extents must be tuple");
  }

  // Return a representation of the block.
  std::string dump() const;

  // Just returns Block<Elem,Rank>
  std::string inline_dump() const;

  // Create a Ref that can be used for lazy computation
  auto operator[](loop_type idx);

  template <char Ident>
  auto operator[](Iter<Ident> &idx);  

  // "Updates" data
  template<typename Rhs, typename...Iterators>
  void assign(const Rhs &rhs, const std::tuple<Iterators...> &idxs);

  // Extents of this block
  const BExtents bextents;
  // Extents to use when determining the lhs loop size
  const BExtents primary_extents;
  // This is essentially a place holder for the data and is the primary different object between the runtime
  // and staged views
  builder::dyn_var<Elem *> data;

};

// A wrapper for a Block/View that can be a part of a lazy computation
template<typename Elem, int Rank, typename BExtents, typename Idxs>
struct Ref : public Expr<Ref<Elem, Rank, BExtents, Idxs>> {

  Ref(Block<Elem, Rank, BExtents> &block_like) : block_like(block_like) {}

  // Chain together lazy computations      
  auto operator[](loop_type idx);

  template <char Ident>
  auto operator[](Iter<Ident> idx);  

  // Trigger stage generation
  void operator=(Elem rhs) {
#ifdef HMDA_VERBOSE
    std::cout << block_like.inline_dump() << "[" << idx_tuple_to_str(idxs) << "]";
    std::cout << " = " << rhs << std::endl;
#endif
    basic_loop<0>(rhs);
  }

  // The underlying Block/View
  Block<Elem, Rank, BExtents> &block_like;
  // The indices used to access this Ref
  Idxs idxs;
  // Hold the iterators values
  std::array<builder::dyn_var<loop_type>, Rank> iters;

private:

  // A simple fully-nested loop
  template<int Depth, typename...Iterators>
  void basic_loop(Elem rhs) {
    if constexpr (Depth == Rank) {
      // do the assignment
      //      block_like.assign(rhs, iters);
    } else {
      auto this_idx = std::get<Depth>(idxs);
      if constexpr (std::is_integral<decltype(this_idx)>()) {
	// scalar value at this dimension, only a single iteration
	//auto new_iters = std::tuple_cat(iters, std::tuple{builder::dyn_var<int>(this_idx)});
	auto &i = iters[Depth];
	for (i = 0; i < 19; i = i + 1) {
	  basic_loop<Depth + 1>(rhs);
	}
      } else {
	// this is an Iter. The extent is the extent of the block_like
	auto extent = std::get<Depth>(block_like.primary_extents);
	auto &i = iters[Depth];	
	for (i = 0; i < extent; i = i + 1) {
	  //	  auto new_iters = std::tuple_cat(iters, std::tuple{builder::dyn_var<int>(i)});	  
	  basic_loop<Depth + 1>(rhs);
	}
      }
    }
  }

};

/*
 * Block impls
 */

template<typename Elem, int Rank, typename BExtents>
std::string Block<Elem, Rank, BExtents>::dump() const {
  std::stringstream ss;
  ss << "Block<" << type_to_str<Elem>() << "," << Rank << ">" << std::endl;
  ss << "  Extents: {" << tuple_to_str(bextents) << "}" << std::endl;
  return ss.str();
}

template<typename Elem, int Rank, typename BExtents>
std::string Block<Elem, Rank, BExtents>::inline_dump() const {
  std::stringstream ss;
  ss << "Block<" << type_to_str<Elem>() << "," << Rank << ">";
  return ss.str();
}

template<typename Elem, int Rank, typename BExtents>
auto Block<Elem, Rank, BExtents>::operator[](loop_type idx) {
  Ref<Elem, Rank, BExtents, std::tuple<loop_type>> ref(*this);
  ref.idxs = std::tuple{idx};
  return ref;
}

template<typename Elem, int Rank, typename BExtents>
template <char Ident>
auto Block<Elem, Rank, BExtents>::operator[](Iter<Ident> idx) {
  Ref<Elem, Rank, BExtents, std::tuple<loop_type>> ref(*this);
  ref.idxs = std::tuple{idx};
  return ref;
}

template<typename Elem, int Rank, typename BExtents>
template<typename Rhs, typename...Iterators>
void Block<Elem, Rank, BExtents>::assign(const Rhs &rhs,
					 const std::tuple<Iterators...> &idxs) {
  auto lidx = linearize<0>(this->bextents, idxs);
  data[lidx] = rhs;
}

/*
 * Ref impls
 */

template<typename Elem, int Rank, typename BExtents, typename Idxs>
auto ref_factory(Block<Elem, Rank, BExtents> &block_like, const Idxs &idxs) {
  auto ref = Ref<Elem, Rank, BExtents, Idxs>(block_like);
  ref.idxs = move(idxs);
  return ref;
}

/*template<typename Elem, int Rank, typename BExtents, typename Idxs>
auto Ref<Elem, Rank, BExtents, Idxs>::operator[](loop_type idx) {
  auto merged_indices = std::tuple_cat(this->idxs, std::tuple{idx});
  auto ref = ref_factory(this->block_like, merged_indices);
  return ref;
}

template<typename Elem, int Rank, typename BExtents, typename Idxs>
template <char Ident>
auto Ref<Elem, Rank, BExtents, Idxs>::operator[](Iter<Ident> idx) {
  auto merged_indices = std::tuple_cat(this->idxs, std::tuple{idx});
  auto ref = ref_factory(this->block_like, merged_indices);
  return ref;
  }*/

}

}
